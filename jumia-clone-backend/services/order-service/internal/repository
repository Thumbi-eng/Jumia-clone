package repository

import "errors"

// Order represents the order model
type Order struct {
	ID     string
	UserID string
	Items  []OrderItem
}

// OrderItem represents an item in an order
type OrderItem struct {
	ProductID string
	Quantity  int
}

// OrderRepository defines the interface for order data access
type OrderRepository interface {
	CreateOrder(order Order) (string, error)
	GetOrderByID(id string) (Order, error)
	GetOrdersByUserID(userID string) ([]Order, error)
}

// InMemoryOrderRepository is an in-memory implementation of OrderRepository
type InMemoryOrderRepository struct {
	orders map[string]Order
}

// NewInMemoryOrderRepository creates a new InMemoryOrderRepository
func NewInMemoryOrderRepository() *InMemoryOrderRepository {
	return &InMemoryOrderRepository{
		orders: make(map[string]Order),
	}
}

// CreateOrder adds a new order to the repository
func (r *InMemoryOrderRepository) CreateOrder(order Order) (string, error) {
	if order.ID == "" {
		return "", errors.New("order ID cannot be empty")
	}
	r.orders[order.ID] = order
	return order.ID, nil
}

// GetOrderByID retrieves an order by its ID
func (r *InMemoryOrderRepository) GetOrderByID(id string) (Order, error) {
	order, exists := r.orders[id]
	if !exists {
		return Order{}, errors.New("order not found")
	}
	return order, nil
}

// GetOrdersByUserID retrieves all orders for a specific user
func (r *InMemoryOrderRepository) GetOrdersByUserID(userID string) ([]Order, error) {
	var userOrders []Order
	for _, order := range r.orders {
		if order.UserID == userID {
			userOrders = append(userOrders, order)
		}
	}
	return userOrders, nil
}